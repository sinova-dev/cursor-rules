# Server Actions Guidelines

## Code Organization

    - Structure directories:
        - Place actions in /app/actions/
        - Create feature-specific locations
        - Use kebab-case naming
        - Write descriptive names
        - Follow feature prefixes
        - Example: user-management.action.ts

    - Organize files:
        - Group imports logically:
          1. Import external dependencies
          2. Import types
          3. Import internal utilities
          4. Import local types
        - Avoid relative imports
        - Limit to 3 parameters per action

## Implementation

    - Define actions:
        - Add 'use server' directive
        - Export named functions
        - Type parameters with 'T'
        - Use async/await patterns
        - Example:
          'use server'

          type TUpdateUserParams = {
            id: string;
            data: TUserData;
            options?: TUpdateOptions;
          };

          export const updateUser = async ({
            id,
            data,
            options = {},
          }: TUpdateUserParams) => {
            // implementation
          };

    - Write functions:
        - Use arrow functions
        - Return early for errors
        - Implement type guards
        - Apply optional chaining
        - Keep functions pure

## Type Safety and Error Handling

    - Implement type safety:
        - Define error types
        - Type parameters and responses
        - Create type-safe forms
        - Build type-safe state
        - Use type guards

    - Handle errors:
        - Implement recovery strategies
        - Structure error logs
        - Validate inputs
        - Report errors
        - Create error boundaries

## Server Action Patterns

    - Handle forms:
        - Configure formAction prop
        - Validate forms with Zod
        - Verify server-side
        - Manage loading states

    - Process mutations:
        - Implement optimistic updates
        - Manage cache revalidation
        - Handle error recovery
        - Type check responses

    - Control state:
        - Use useFormState hook
        - Type check server state
        - Handle error states
        - Show loading indicators

## Security

    - Validate input:
        - Implement Zod validation
        - Check types thoroughly
        - Sanitize data
        - Control rate limits

    - Secure authentication:
        - Type check sessions
        - Verify roles
        - Validate permissions
        - Handle auth errors

    - Protect data:
        - Prevent SQL injection
        - Block XSS attacks
        - Enable CSRF protection
        - Sanitize inputs

## Performance

    - Configure caching:
        - Set cache headers
        - Manage revalidation
        - Control invalidation
        - Enable edge caching

    - Optimize performance:
        - Minimize client state
        - Handle loading states
        - Update optimistically
        - Stream responses

## Testing

    - Create tests:
        - Write action tests
        - Verify types
        - Test error cases
        - Build integration tests

    - Structure tests:
        - Name files properly
        - Organize test structure
        - Create mock data
        - Test error scenarios

## Monitoring

    - Track errors:
        - Structure logging
        - Report errors
        - Monitor performance
        - Analyze usage

    - Debug code:
        - Use development tools
        - Trace errors
        - Profile performance
        - Analyze logs
