# React and Next.js Components

## Component Architecture

    - Define components using arrow functions:
        - Always use arrow function syntax (required by 'react/function-component-definition')
        - Example: const MyComponent = ({ prop }: TProps) => { ... }
        - Export as named exports (import/no-default-export rule)

    - Apply TypeScript naming conventions:
        - Prefix type aliases with 'T' (e.g., TProps)
        - Prefix interfaces with 'I' (e.g., IProps)
        - Start boolean props with prefixes:
          is, should, has, can, was, did, will, use, with, disable
        - Use union types and discriminated unions for better type safety
        - Leverage generics for reusable type-safe code

    - Maintain small and focused components:
        - Limit JSX depth to 5 levels (react/jsx-max-depth)
        - Restrict parameters to 3 (max-params)
        - Create one component per file (react/no-multi-comp)
        - Write prop types documentation
        - Document shared components

    - Follow file and folder naming:
        - Name component files (.tsx) in PascalCase (e.g., Button.tsx, UserProfile.tsx)
        - Write other files (.ts, .js) in kebab-case
        - Apply Next.js app router conventions for special files:
          layout, page, error, loading, etc.

    - Handle props properly:
        - Sort props with reserved props first
        - Start event handler props with 'on'
        - Implement default arguments for function props
        - Example:
          const Button = ({
            children,
            className,
            onClick,
            isDisabled = false
          }: TProps) => { ... }

    - Structure imports correctly:
        - Avoid relative imports (use absolute paths)
        - Use inline type imports with 'type' keyword for better tree-shaking
        - Example:
          import type { type ComponentProps } from 'react'
          import { Button } from '@/components/ui'

    - Structure components properly:
        - Define props using type (not interface)
        - Export components as named exports
        - Example:
          type TButtonProps = {
            onClick: () => void;
            isDisabled?: boolean;
          }

          export const Button = ({
            onClick,
            isDisabled = false
          }: TButtonProps) => { ... }

## Client Components

    - Implement 'use client' only when necessary:
        - Build interactive UI elements
        - Access Browser APIs
        - Handle events
        - Manage client-side state

    - Minimize client-side state

    - Implement proper hooks patterns

    - Handle events properly

    - Manage component lifecycle

    - Implement error boundaries

    - Handle loading states

## UI Components

    - Implement Shadcn UI and Radix UI

    - Ensure accessibility (a11y)

    - Apply Tailwind patterns

    - Build responsive designs

    - Implement animations thoughtfully

    - Configure theming

    - Create component variants

## Performance

    - Split code effectively

    - Implement lazy loading

    - Apply memoization

    - Optimize rendering

    - Optimize bundles

    - Implement caching

    - Load resources efficiently

## Forms and Validation

    - Implement Zod validation

    - Handle form submissions

    - Display error messages

    - Ensure accessibility

    - Show loading states

    - Validate inputs

    - Provide success feedback

## State Management

    - Keep state close to usage

    - Define context boundaries

    - Update state immutably

    - Persist state when needed

    - Synchronize state properly

    - Handle error states

    - Manage loading states

## Component Organization

    - Structure by features

    - Define module boundaries

    - Separate concerns properly

    - Order imports logically

    - Organize types effectively

    - Write documentation

    - Create test patterns

## Image Optimization

    - Use Next Image component

    - Implement lazy loading

    - Choose proper formats

    - Define correct sizes

    - Add placeholder images

    - Configure caching

    - Set up CDN integration

## Development Practices

    - Write comprehensive tests

    - Use TypeScript features

    - Document code thoroughly

    - Debug effectively

    - Handle errors properly

    - Review code systematically

    - Control versions properly

    - Use Zod for form validation.

    - Wrap client components in Suspense with fallback.

    - Use dynamic loading for non-critical components.

    - Optimize images: WebP format, size data, lazy loading.
