# React and Next.js Components

## Component Architecture

    - Define components using arrow functions:
        - Write components using arrow function syntax
        - Export components as named exports
        - Follow the example: const MyComponent = ({ prop }: TProps) => { ... }
        - Avoid using function declarations

    - Apply TypeScript naming conventions:
        - Prefix type aliases with 'T' (e.g., TProps)
        - Prefix interfaces with 'I' (e.g., IProps)
        - Start boolean props with verbs (is, should, has, can, was, did)
        - Implement union types for better type safety
        - Create reusable code with generics

    - Maintain component focus:
        - Limit JSX depth to 5 levels
        - Restrict parameters to 3
        - Create separate files for each component
        - Write documentation for prop types
        - Document all shared components

    - Structure files and folders:
        - Name component files in PascalCase (e.g., Button.tsx)
        - Write utility files in kebab-case
        - Follow Next.js app router conventions
        - Organize by feature/domain

    - Handle props effectively:
        - Sort props with reserved props first
        - Prefix event handlers with 'on'
        - Implement default arguments
        - Follow the example:
          const Button = ({
            children,
            className,
            onClick,
            isDisabled = false
          }: TProps) => { ... }

    - Organize code structure:
        - Place types at the top of file
        - Order components logically:
          1. Define types and interfaces
          2. Export main component
          3. Write subcomponents
          4. Implement helper functions
          5. Define static content
        - Apply modern patterns:
          - Use optional chaining
          - Implement nullish coalescing
          - Apply array/object spread
          - Write clean destructuring

## Client Components

    - Implement client features:
        - Add 'use client' when needed
        - Build interactive UI elements
        - Access Browser APIs
        - Handle user events
        - Manage client state

    - Optimize performance:
        - Minimize client-side state
        - Implement proper hooks
        - Handle events efficiently
        - Manage component lifecycle

    - Handle errors:
        - Implement error boundaries
        - Create loading states
        - Provide fallback UI

## UI Components

    - Build UI components:
        - Integrate Shadcn UI and Radix UI
        - Ensure accessibility (a11y)
        - Apply Tailwind patterns
        - Create responsive designs
        - Implement animations thoughtfully
        - Configure theming
        - Design component variants

## Performance

    - Optimize code:
        - Split code strategically
        - Implement lazy loading
        - Apply memoization
        - Enhance rendering
        - Minimize bundles
        - Configure caching
        - Load resources efficiently

## Forms and Validation

    - Build forms:
        - Implement Zod validation
        - Handle form submissions
        - Display error messages
        - Ensure accessibility
        - Show loading states
        - Validate inputs
        - Provide success feedback

## State Management

    - Manage state:
        - Keep state close to usage
        - Define context boundaries
        - Update state immutably
        - Persist state when needed
        - Synchronize state properly
        - Handle error states
        - Control loading states

## Component Organization

    - Organize components:
        - Structure by features
        - Define module boundaries
        - Separate concerns properly
        - Order imports logically
        - Organize types effectively
        - Write documentation
        - Create test patterns

## Image Optimization

    - Optimize images:
        - Use Next Image component
        - Implement lazy loading
        - Choose proper formats
        - Define correct sizes
        - Add placeholder images
        - Configure caching
        - Set up CDN integration

## Development Practices

    - Implement practices:
        - Write comprehensive tests
        - Use TypeScript features
        - Document code thoroughly
        - Debug effectively
        - Handle errors properly
        - Review code systematically
        - Control versions properly
        - Configure Zod validation
        - Wrap Suspense components
        - Load components dynamically
        - Optimize image formats
